/**
 * Firebase Cloud Functions 後端邏輯
 *
 * 協議： https.onCall (✅ 已升級至 V2 SDK 語法)
 * 儲存： 通知儲存在 'users' 文件內的 'notifications' 陣列中
 *
 * ✅ 功能：已補全所有通知函數
 */

// ✅ 修正：使用 V2 模組化匯入，並確保名稱是正確的
const {https} = require("firebase-functions/v2/https");
const {setGlobalOptions} = require("firebase-functions/v2");
const {onDocumentCreated} = require("firebase-functions/v2/firestore");
const admin = require("firebase-admin");

if (!admin.apps.length) {
  admin.initializeApp();
}
const db = admin.firestore();
const fieldValue = admin.firestore.FieldValue;

const REGION = "us-central1";
// ✅ 修正：使用 V2 語法設定全域區域
setGlobalOptions({region: REGION});

/**
 * 產生自訂 appId，格式 GUNBOOJO-XXXX
 * @return {string} appId
 */
const generateAppId = () => {
  const chars =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let randomPart = "";
  for (let i = 0; i < 4; i++) {
    randomPart += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return `GUNBOOJO-${randomPart}`;
};

// ======================================================
// 1. 帳號與好友關係管理 (Callable Functions)
// ======================================================

/**
 * 建立使用者 Profile (使用 https.onCall)
 */
// ✅ 修正：使用 V2 onCall 語法
exports.createUser = https.onCall(async (request) => {
  const {data, context} = request;
  if (!context.auth) {
    throw new https.HttpsError(
        "unauthenticated", "User must be authenticated.");
  }
  const {uid, displayName, email} = data;
  if (!uid || !displayName || !email) {
    throw new https.HttpsError(
        "invalid-argument", "Missing user info.");
  }
  if (context.auth.uid !== uid) {
    throw new https.HttpsError(
        "permission-denied", "Cannot create a profile for another user.");
  }

  // 檢查暱稱 (需要索引)
  const existingName = await db
      .collection("users")
      .where("displayName", "==", displayName)
      .get();
  if (!existingName.empty) {
    throw new https.HttpsError(
        "already-exists", "Display name already taken");
  }

  const appId = generateAppId();
  const displayNameLower = displayName.toLowerCase().trim();
  const timestamp = fieldValue.serverTimestamp();

  const newUserProfile = {
    id: uid,
    appId: appId, // 新用戶會建立 appId
    uid: uid,
    friendCode: appId, // 新用戶也會建立 friendCode (確保相容性)
    displayName,
    displayName_lower: displayNameLower,
    email,
    createdAt: timestamp,
    updatedAt: timestamp,
    avatarUrl: `https-://picsum.photos/200/200?random=${uid}`,
    friends: [],
    friendRequests: [],
    incomingRequests: [],
    outgoingRequests: [],
    notifications: [],
    level: 1,
    xp: 0,
    xpToNextLevel: 100,
    // ✅ 修正：新用戶註冊領取 50 酒幣
    points: 50,
    missionsCompleted: 0,
    checkIns: 0,
    latlng: {lat: 25.04, lng: 121.53},
  };

  await db.collection("users").doc(uid).set(newUserProfile);
  return newUserProfile;
});

/**
 * 搜尋使用者 (✅ 僅搜尋 appId)
 */
// ✅ 修正：使用 V2 onCall 語法
exports.searchUsers = https.onCall(async (request) => {
  const {data, context} = request;
  if (!context.auth) {
    throw new https.HttpsError(
        "unauthenticated", "Must be authenticated.");
  }

  const {query} = data;
  if (!query) {
    throw new https.HttpsError("invalid-argument", "Missing query");
  }

  const results = [];
  const queryUpper = query.toUpperCase().trim();

  try {
    // ✅ 關鍵修改：只搜尋 appId
    const appIdQuery = db
        .collection("users")
        .where("appId", "==", queryUpper)
        .limit(1);
    const appIdSnap = await appIdQuery.get();

    appIdSnap.forEach((doc) => {
      const userData = doc.data();
      results.push({
        id: doc.id,
        appId: userData.appId,
        displayName: userData.displayName,
        avatarUrl: userData.avatarUrl || "",
      });
    });
  } catch (err) {
    console.warn(
        "searchUsers: 'appId' query failed. Check Index.",
        err.message);
  }

  return results;
});


/**
 * 發送好友邀請
 */
// ✅ 修正：使用 V2 onCall 語法
exports.sendFriendRequest = https.onCall(async (request) => {
  const {data, context} = request;
  if (!context.auth) {
    throw new https.HttpsError(
        "unauthenticated", "Must be authenticated.");
  }
  const myUid = context.auth.uid;
  const {friendId} = data;
  if (!friendId || myUid === friendId) {
    throw new https.HttpsError(
        "invalid-argument", "Invalid input.");
  }
  const userSnap = await db.collection("users").doc(myUid).get();
  if (!userSnap.exists) {
    throw new https.HttpsError(
        "not-found", "Your user profile not found.");
  }
  // ✅ 修正：提供備用值 "Unknown"，防止 userAppId 為 undefined
  const userAppId =
    userSnap.data().appId || userSnap.data().friendCode || "UnknownUser";

  const friendRef = db.collection("users").doc(friendId);
  const friendSnap = await friendRef.get();
  if (!friendSnap.exists) {
    throw new https.HttpsError("not-found", "Friend not found");
  }
  const friendData = friendSnap.data();

  // ✅ 修正：安全地檢查 friends 陣列
  if (friendData &&
      friendData.friends &&
      friendData.friends.includes(myUid)) {
    throw new https.HttpsError(
        "already-exists", "You are already friends.");
  }

  // ✅ 修正：安全地過濾 friendRequests 和 notifications 陣列
  const friendRequests = (friendData.friendRequests || []).filter(String);
  const notifications = (friendData.notifications || []).filter(Boolean);

  if (!friendRequests.includes(myUid)) {
    notifications.push({
      id: generateAppId(),
      type: "friend_request",
      from: userAppId,
      fromUid: myUid,
      timestamp: fieldValue.serverTimestamp(),
      read: false,
    });
    await friendRef.update({
      friendRequests: fieldValue.arrayUnion(myUid),
      notifications: notifications, // 寫入已過濾的乾淨陣列
    });
  } else {
    throw new https.HttpsError(
        "already-exists", "Request already sent.");
  }
  return {success: true};
});

/**
 * 回應好友邀請
 */
// ✅ 修正：使用 V2 onCall 語法
exports.respondFriendRequest = https.onCall(async (request) => {
  const {data, context} = request;
  if (!context.auth) {
    throw new https.HttpsError(
        "unauthenticated", "Must be authenticated.");
  }
  const {requesterId, accept} = data;
  if (!requesterId || typeof accept !== "boolean") {
    throw new https.HttpsError("invalid-argument", "Missing info");
  }
  const myUid = context.auth.uid;
  const userRef = db.collection("users").doc(myUid);
  const userSnap = await userRef.get();
  if (!userSnap.exists) {
    throw new https.HttpsError("not-found", "User not found");
  }
  const userData = userSnap.data();
  const userAppId = userData.appId || userData.friendCode;

  await userRef.update({
    friendRequests: fieldValue.arrayRemove(requesterId),
  });

  const requesterRef = db.collection("users").doc(requesterId);
  const requesterSnap = await requesterRef.get();
  if (!requesterSnap.exists) {
    throw new https.HttpsError("not-found", "Requester not found");
  }
  const requesterData = requesterSnap.data();
  if (accept) {
    await userRef.update({
      friends: fieldValue.arrayUnion(requesterId),
    });
    // ✅ 修正：安全地過濾 notifications 陣列
    const notifications = (requesterData.notifications || []).filter(Boolean);
    notifications.push({
      id: generateAppId(),
      type: "friend_accept",
      from: userAppId,
      fromUid: myUid,
      timestamp: fieldValue.serverTimestamp(),
      read: false,
    });
    await requesterRef.update({
      friends: fieldValue.arrayUnion(myUid),
      notifications: notifications,
    });
  }
  return {success: true};
});


/**
 * 取得好友列表 (✅ 已重構為最安全版本)
 */
// ✅ 修正：使用 V2 onCall 語法
exports.getFriends = https.onCall(async (request) => {
  const {context} = request;
  if (!context.auth) {
    throw new https.HttpsError(
        "unauthenticated", "Must be authenticated.");
  }
  const authUid = context.auth.uid;
  const userSnap = await db.collection("users").doc(authUid).get();
  if (!userSnap.exists) {
    throw new https.HttpsError("not-found", "User not found");
  }

  const friendsUids = userSnap.data().friends || [];

  // 1. 過濾掉無效的 UID
  const validFriendUids = friendsUids.filter((uid) => {
    return uid && typeof uid === "string" && uid.trim() !== "";
  });

  if (validFriendUids.length === 0) {
    return [];
  }

  // 2. 關鍵修復：改用 Promise.all 搭配個別的 get()
  const friendPromises = validFriendUids.map((fid) => {
    return db.collection("users").doc(fid).get().catch((error) => {
      console.error(
          `Failed to fetch friend with UID: ${fid}`, error);
      return null;
    });
  });

  const friendSnaps = await Promise.all(friendPromises);

  const friendsData = [];
  friendSnaps.forEach((friendSnap) => {
    if (friendSnap && friendSnap.exists) {
      const friendData = friendSnap.data();
      if (friendData) {
        friendsData.push({
          id: friendSnap.id,
          appId: friendData.appId || friendData.friendCode,
          displayName: friendData.displayName,
          avatarUrl: friendData.avatarUrl,
          level: friendData.level,
          latlng: friendData.latlng,
          xp: friendData.xp,
          xpToNextLevel: friendData.xpToNextLevel,
          missionsCompleted: friendData.missionsCompleted,
          checkIns: friendData.checkIns,
        });
      }
    }
  });

  return friendsData;
});


/**
 * 取得通知列表
 */
// ✅ 修正：使用 V2 onCall 語法
exports.getNotifications = https.onCall(
    async (request) => {
      const {context} = request;
      if (!context.auth) {
        throw new https.HttpsError(
            "unauthenticated",
            "Must be authenticated.",
        );
      }
      const authUid = context.auth.uid;
      const userSnap = await db.collection("users").doc(authUid).get();
      if (!userSnap.exists) {
        throw new https.HttpsError(
            "not-found",
            "User not found",
        );
      }
      const notifications = userSnap.data().notifications || [];
      notifications.sort((a, b) => {
        if (a.timestamp && b.timestamp) {
          const timeA = a.timestamp._seconds || a.timestamp.seconds || 0;
          const timeB = b.timestamp._seconds || b.timestamp.seconds || 0;
          return timeB - timeA;
        } else if (a.timestamp) {
          return -1;
        } else if (b.timestamp) {
          return 1;
        }
        return 0;
      });
      return notifications;
    },
);

// =================================================================
// 3. 通知 (Callable Functions)
// =================================================================

/**
 * 前端在「完成任務」時呼叫此函數
 * @param {object} data - {missionName: "任務名稱", xpReward: 50}
 */
// ✅ 修正：使用 V2 onCall 語法
exports.triggerMissionComplete = https.onCall(
    async (request) => {
      const {data, context} = request;
      if (!context.auth) {
        throw new https.HttpsError(
            "unauthenticated", "Must be authenticated.");
      }
      const {missionName, xpReward} = data;
      if (!missionName || !xpReward) {
        throw new https.HttpsError(
            "invalid-argument", "Missing mission info.");
      }

      const userRef = db.collection("users").doc(context.auth.uid);
      const notification = {
        id: generateAppId(),
        type: "mission_complete",
        message: `任務完成：${missionName}！您獲得了 ${xpReward} 經驗值。`,
        timestamp: fieldValue.serverTimestamp(),
        read: false,
      };

      await userRef.update({
        notifications: fieldValue.arrayUnion(notification),
        missionsCompleted: fieldValue.increment(1),
        xp: fieldValue.increment(xpReward),
      });

      return {success: true};
    },
);

/**
 * 前端在「等級升級」時呼叫此函數
 * @param {object} data - {newLevel: 3}
 */
// ✅ 修正：使用 V2 onCall 語法
exports.triggerLevelUp = https.onCall(async (request) => {
  const {data, context} = request;
  if (!context.auth) {
    throw new https.HttpsError(
        "unauthenticated", "Must be authenticated.");
  }
  const {newLevel} = data;
  if (!newLevel) {
    throw new https.HttpsError(
        "invalid-argument", "Missing newLevel.");
  }

  const userRef = db.collection("users").doc(context.auth.uid);
  const notification = {
    id: generateAppId(),
    type: "level_up",
    message: `恭喜！您已升級至 ${newLevel} 等！`,
    timestamp: fieldValue.serverTimestamp(),
    read: false,
  };

  await userRef.update({
    notifications: fieldValue.arrayUnion(notification),
  });

  return {success: true};
});

/**
 * 前端在「收到優惠卷」時呼叫此函數
 * @param {object} data - {couponName: "啤酒買一送一"}
 */
// ✅ 修正：使用 V2 onCall 語法
exports.triggerCouponNotification = https.onCall(
    async (request) => {
      const {data, context} = request;
      if (!context.auth) {
        throw new https.HttpsError(
            "unauthenticated", "Must be authenticated.");
      }
      const {couponName} = data;
      if (!couponName) {
        throw new https.HttpsError(
            "invalid-argument", "Missing couponName.");
      }

      const userRef = db.collection("users").doc(context.auth.uid);
      const notification = {
        id: generateAppId(),
        type: "new_coupon",
        message: `您已獲得一張新的優惠卷：${couponName}！`,
        linkTo: "/coupons",
        timestamp: fieldValue.serverTimestamp(),
        read: false,
      };

      await userRef.update({
        notifications: fieldValue.arrayUnion(notification),
      });

      return {success: true};
    },
);

// =================================================================
// 4. 動態牆 (Feed)
// =================================================================

/**
 * 取得好友和自己的貼文 (動態牆)
 * @param {object} data - (空)
 * @param {functions.https.CallableContext} context - 函式上下文
 * @return {Promise<Array<object>>} 貼文列表
 * ⚠️ 需要複合索引: posts, authorId asc, createdAt desc
 */
// ✅ 修正：使用 V2 onCall 語法
exports.getFeed = https.onCall(async (request) => {
  const {context} = request;
  if (!context.auth) {
    throw new https.HttpsError(
        "unauthenticated", "Must be authenticated.");
  }

  const myUid = context.auth.uid;

  // 1. 取得自己的 Profile，獲取好友列表
  const userSnap = await db.collection("users").doc(myUid).get();
  if (!userSnap.exists) {
    throw new https.HttpsError("not-found", "User not found");
  }

  const friends = userSnap.data().friends || [];

  // 2. 過濾掉無效的 UID，防止 'in' 查詢崩潰
  const validFriendUids = friends.filter((uid) => {
    return uid && typeof uid === "string" && uid.trim() !== "";
  });

  // 3. 建立要查詢的 ID 列表 (包含自己和「有效的好友」)
  const feedUids = [myUid, ...validFriendUids];

  // 4. Firestore 'in' 查詢限制 (最多 30 個)
  if (feedUids.length > 30) {
    feedUids.splice(30);
  }

  if (feedUids.length === 0) {
    return [];
  }

  try {
    // 5. 查詢 'posts' 集合
    // ⚠️ 這是複合查詢，如果失敗，請檢查索引。
    const postsSnap = await db
        .collection("posts")
        .where("authorId", "in", feedUids)
        .orderBy("createdAt", "desc")
        .limit(30)
        .get();

    const feedItems = [];
    postsSnap.forEach((doc) => {
      feedItems.push({
        id: doc.id,
        ...doc.data(),
      });
    });

    return feedItems;
  } catch (error) {
    // 捕捉錯誤，回報給前端一個更具體的錯誤
    console.error(
        "getFeed failed (LIKELY INDEX ISSUE):", error.message);
    throw new https.HttpsError(
        "internal",
        "Feed query failed (Index missing or building).",
    );
  }
});


// =================================================================
// 5. 更新使用者位置
// =================================================================

/**
 * 前端在「取得 GPS」時呼叫此函數
 * @param {object} data - {latlng: {lat: 25.04, lng: 121.53}}
 */
// ✅ 修正：使用 V2 onCall 語法
exports.updateUserLocation = https.onCall(
    async (request) => {
      const {data, context} = request;
      if (!context.auth) {
        throw new https.HttpsError(
            "unauthenticated", "Must be authenticated.");
      }
      const {latlng} = data;
      if (!latlng || typeof latlng.lat !== "number" ||
        typeof latlng.lng !== "number") {
        throw new https.HttpsError(
            "invalid-argument", "Invalid latlng object.");
      }

      const userRef = db.collection("users").doc(context.auth.uid);

      await userRef.update({
        latlng: latlng, // 更新 latlng 欄位
        updatedAt: fieldValue.serverTimestamp(), // 同時更新「最後上線時間」
      });

      return {success: true};
    },
);

// =================================================================
// 6. 聊天通知 (Firestore 觸發器)
// =================================================================

/**
 * 監聽 /chats/{chatId}/messages/{messageId} 的新文件
 * 並發送通知給聊天室的「另一位」用戶
 */
// ✅ 修正：使用 V2 onDocumentCreated 觸發器
exports.sendChatNotification = onDocumentCreated(
    "chats/{chatId}/messages/{messageId}", async (event) => {
      const {data: snapshot, params} = event;
      if (!snapshot) {
        console.error("No data associated with the event.");
        return null;
      }
      const messageData = snapshot.data();
      const chatId = params.chatId;
      const senderId = messageData.senderId;

      if (!messageData || !chatId || !senderId) {
        console.error("Chat notification missing data.", {chatId, senderId});
        return null;
      }

      // 1. 取得聊天室的 metadata，找出「接收者」
      const chatDoc = await db.collection("chats").doc(chatId).get();
      if (!chatDoc.exists) {
        console.error(`Chat document ${chatId} not found.`);
        return null;
      }

      const participants = chatDoc.data().participants || [];
      const recipientId = participants.find((uid) => uid !== senderId);

      if (!recipientId) {
        console.warn(`Could not find recipient in chat ${chatId}.`, {
          participants,
          senderId,
        });
        return null;
      }

      // 2. 取得「發送者」的 Profile (為了顯示名字)
      const senderSnap = await db.collection("users").doc(senderId).get();
      if (!senderSnap.exists) {
        console.error(`Sender profile ${senderId} not found.`);
        return null;
      }
      const senderName = senderSnap.data().displayName || "有人";

      // 3. 準備通知物件
      const notification = {
        id: generateAppId(), // 產生隨機 ID
        type: "chat_message",
        message: `${senderName} 傳送了一則新訊息給您。`,
        from: senderName,
        fromUid: senderId,
        linkTo: `/chat/${chatId}`, // 讓 App 可以點擊跳轉
        timestamp: fieldValue.serverTimestamp(),
        read: false,
      };

      // 4. 將通知寫入「接收者」的 notifications 陣列
      const recipientRef = db.collection("users").doc(recipientId);
      try {
        await recipientRef.update({
          notifications: fieldValue.arrayUnion(notification),
        });
        console.log(
            `Chat notification sent to ${recipientId} from ${senderId}`);
      } catch (error) {
        console.error(
            `Failed to send chat notification to ${recipientId}`, error);
      }
      return null;
    },
);

// =================================================================
// 7. 【新功能】動態牆留言 (Callable + 觸發器)
// =================================================================

/**
 * 前端在「送出留言」時呼叫此函數
 * @param {object} data - {postId: "...", commentText: "..."}
 */
// ✅ 修正：使用 V2 onCall 語法
exports.addCommentToPost = https.onCall(async (request) => {
  const {data, context} = request;
  if (!context.auth) {
    throw new https.HttpsError(
        "unauthenticated", "Must be authenticated.");
  }
  const {postId, commentText} = data;
  const commenterUid = context.auth.uid;

  if (!postId || !commentText || !commenterUid) {
    throw new https.HttpsError(
        "invalid-argument", "Missing data.");
  }

  // 1. 取得留言者的 Profile
  const userSnap = await db.collection("users").doc(commenterUid).get();
  if (!userSnap.exists) {
    throw new https.HttpsError("not-found", "Commenter profile not found.");
  }
  const userData = userSnap.data();

  // 2. 建立留言物件
  const newComment = {
    authorId: commenterUid,
    authorDisplayName: userData.displayName,
    authorAvatarUrl: userData.avatarUrl,
    text: commentText,
    timestamp: fieldValue.serverTimestamp(),
  };

  // 3. 將留言寫入 'posts' 集合下的 'comments' 子集合
  await db
      .collection("posts")
      .doc(postId)
      .collection("comments")
      .add(newComment);

  return {success: true, comment: newComment};
});

/**
 * 【自動觸發】監聽 /posts/{postId}/comments/{commentId} 的新文件
 * 並發送通知給「貼文作者」
 */
// ✅ 修正：使用 V2 onDocumentCreated 觸發器
exports.sendCommentNotification = onDocumentCreated(
    "posts/{postId}/comments/{commentId}", async (event) => {
      const {data: snapshot, params} = event;
      // ✅ 修正：确保 snapshot 不是 undefined
      if (!snapshot) {
        console.error("No data associated with the event.");
        return null;
      }
      const commentData = snapshot.data();
      const postId = params.postId;
      const commenterId = commentData.authorId; // 留言者 ID

      // 1. 取得貼文，找出「貼文作者」
      const postDoc = await db.collection("posts").doc(postId).get();
      if (!postDoc.exists) {
        console.error(`Post ${postId} not found.`);
        return null;
      }
      const postAuthorId = postDoc.data().authorId; // 貼文作者 ID

      // 2. 如果作者幫自己留言，不要發通知
      if (postAuthorId === commenterId) {
        console.log("User commented on their own post. No notification.");
        return null;
      }

      // 3. 準備通知物件 (留言者的名字已在 commentData 中)
      const commenterName = commentData.authorDisplayName || "有人";
      const notification = {
        id: generateAppId(),
        type: "new_comment",
        message: `${commenterName} 在您的貼文上留言。`,
        from: commenterName,
        fromUid: commenterId,
        linkTo: `/post/${postId}`, // (假設您有單一貼文頁面)
        timestamp: fieldValue.serverTimestamp(),
        read: false,
      };

      // 4. 將通知寫入「貼文作者」的 notifications 陣列
      const recipientRef = db.collection("users").doc(postAuthorId);
      try {
        await recipientRef.update({
          notifications: fieldValue.arrayUnion(notification),
        });
        console.log(
            `Comment notification sent to ${postAuthorId} from ${commenterId}`);
      } catch (error) {
        console.error(
            `Failed to send comment notification to ${postAuthorId}`, error);
      }
      return null;
    },
);

const {https} = require("firebase-functions/v2/https");
const {onDocumentCreated} = require("firebase-functions/v2/firestore");
const {setGlobalOptions} = require("firebase-functions/v2");
const functions = require("firebase-functions");
const admin = require("firebase-admin");

if (!admin.apps.length) admin.initializeApp();
const db = admin.firestore();
const fieldValue = admin.firestore.FieldValue;
const REGION = "us-central1";
setGlobalOptions({region: REGION});

// ======================================
// 工具函數
// ======================================
const generateAppId = () => {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let r = "";
  for (let i = 0; i < 4; i++)
    r += chars.charAt(Math.floor(Math.random() * chars.length));
  return `GUNBOOJO-${r}`;
};

// ======================================
// 1. 使用者管理
// ======================================
exports.createUser = functions.https.onCall(async (req) => {
  const {data, context} = req;
  if (!context.auth)
    throw new https.HttpsError("unauthenticated", "User must be authenticated.");

  const {uid, displayName, email, missions} = data;
  if (!uid || !displayName || !email || !missions)
    throw new https.HttpsError("invalid-argument", "Missing user info");

  if (context.auth.uid !== uid)
    throw new https.HttpsError("permission-denied", 
      "Cannot create profile for another user.");

  const existingName = await db.collection("users")
    .where("displayName", "==", displayName).get();
  if (!existingName.empty)
    throw new https.HttpsError("already-exists", "Display name taken");

  const appId = generateAppId();
  const displayNameLower = displayName.toLowerCase().trim();
  const timestamp = fieldValue.serverTimestamp();

  const newUser = {
    id: uid,
    appId,
    uid,
    friendCode: appId,
    displayName,
    displayName_lower: displayNameLower,
    email,
    createdAt: timestamp,
    updatedAt: timestamp,
    avatarUrl: `https://picsum.photos/200/200?random=${uid}`,
    friends: [],
    friendRequests: [],
    incomingRequests: [],
    outgoingRequests: [],
    level: 1,
    xp: 0,
    xpToNextLevel: 100,
    points: 50,
    missionsCompleted: 0,
    checkIns: 0,
    latlng: {lat: 25.04, lng: 121.53},
    missions
  };

  await db.collection("users").doc(uid).set(newUser);
  return newUser;
});

exports.searchUsers = functions.https.onCall(async (req) => {
  const {data, context} = req;
  if (!context.auth)
    throw new https.HttpsError("unauthenticated", "Must be authenticated.");
  const {query} = data;
  if (!query)
    throw new https.HttpsError("invalid-argument", "Missing query");

  const results = [];
  const q = query.toUpperCase().trim();
  try {
    const snap = await db.collection("users")
      .where("appId", "==", q).limit(1).get();
    snap.forEach(doc => {
      const u = doc.data();
      results.push({
        id: doc.id,
        appId: u.appId,
        displayName: u.displayName,
        avatarUrl: u.avatarUrl || ""
      });
    });
  } catch (err) {
    console.warn("searchUsers failed.", err.message);
  }
  return results;
});

exports.sendFriendRequest = functions.https.onCall(async (req) => {
  const {data, context} = req;
  if (!context.auth)
    throw new https.HttpsError("unauthenticated", "Must be authenticated.");

  const myUid = context.auth.uid;
  const {friendId} = data;
  if (!friendId || myUid === friendId)
    throw new https.HttpsError("invalid-argument", "Invalid input.");

  const userSnap = await db.collection("users").doc(myUid).get();
  if (!userSnap.exists)
    throw new https.HttpsError("not-found", "Your profile not found.");
  const userAppId = userSnap.data().appId || userSnap.data().friendCode || "Unknown";

  const friendRef = db.collection("users").doc(friendId);
  const friendSnap = await friendRef.get();
  if (!friendSnap.exists)
    throw new https.HttpsError("not-found", "Friend not found.");

  const friendData = friendSnap.data();
  if (friendData && friendData.friends && friendData.friends.includes(myUid))
    throw new https.HttpsError("already-exists", "Already friends.");

  const friendRequests = (friendData.friendRequests || []).filter(String);
  if (!friendRequests.includes(myUid)) {
    const notification = {
      id: generateAppId(),
      type: "friend_request",
      from: userAppId,
      fromUid: myUid,
      timestamp: fieldValue.serverTimestamp(),
      read: false
    };
    await db.collection("users").doc(friendId)
      .collection("notifications").add(notification);
    await friendRef.update({friendRequests: fieldValue.arrayUnion(myUid)});
  } else {
    throw new https.HttpsError("already-exists", "Request already sent.");
  }
  return {success: true};
});

exports.respondFriendRequest = functions.https.onCall(async (req) => {
  const {data, context} = req;
  if (!context.auth)
    throw new https.HttpsError("unauthenticated", "Must be authenticated.");
  const {requesterId, accept} = data;
  if (!requesterId || typeof accept !== "boolean")
    throw new https.HttpsError("invalid-argument", "Missing info");

  const myUid = context.auth.uid;
  const userRef = db.collection("users").doc(myUid);
  const userSnap = await userRef.get();
  if (!userSnap.exists)
    throw new https.HttpsError("not-found", "User not found.");
  const userAppId = userSnap.data().appId || userSnap.data().friendCode;

  await userRef.update({friendRequests: fieldValue.arrayRemove(requesterId)});
  const requesterRef = db.collection("users").doc(requesterId);
  if (accept) {
    await userRef.update({friends: fieldValue.arrayUnion(requesterId)});
    const notification = {
      id: generateAppId(),
      type: "friend_accept",
      from: userAppId,
      fromUid: myUid,
      timestamp: fieldValue.serverTimestamp(),
      read: false
    };
    await db.collection("users").doc(requesterId)
      .collection("notifications").add(notification);
    await requesterRef.update({friends: fieldValue.arrayUnion(myUid)});
  }
  return {success: true};
});

// ================================
// 2. 通知系統
// ================================
exports.triggerMissionComplete = functions.https.onCall(async (req) => {
  const {data, context} = req;
  if (!context.auth)
    throw new https.HttpsError("unauthenticated", "Must be authenticated.");
  const {missionName, xpReward} = data;
  if (!missionName || !xpReward)
    throw new https.HttpsError("invalid-argument", "Missing mission info");

  const userRef = db.collection("users").doc(context.auth.uid);
  const notification = {
    id: generateAppId(),
    type: "mission_complete",
    message: `任務完成：${missionName}！獲得 ${xpReward} 經驗值。`,
    timestamp: fieldValue.serverTimestamp(),
    read: false
  };
  await userRef.collection("notifications").add(notification);
  await userRef.update({
    missionsCompleted: fieldValue.increment(1),
    xp: fieldValue.increment(xpReward)
  });
  return {success: true};
});

exports.triggerLevelUp = functions.https.onCall(async (req) => {
  const {data, context} = req;
  if (!context.auth)
    throw new https.HttpsError("unauthenticated", "Must be authenticated.");
  const {newLevel} = data;
  if (!newLevel)
    throw new https.HttpsError("invalid-argument", "Missing newLevel");

  const notification = {
    id: generateAppId(),
    type: "level_up",
    message: `恭喜！您已升級至 ${newLevel} 等！`,
    timestamp: fieldValue.serverTimestamp(),
    read: false
  };
  await db.collection("users").doc(context.auth.uid)
    .collection("notifications").add(notification);
  return {success: true};
});

exports.triggerCouponNotification = functions.https.onCall(async (req) => {
  const {data, context} = req;
  if (!context.auth)
    throw new https.HttpsError("unauthenticated", "Must be authenticated.");
  const {couponName} = data;
  if (!couponName)
    throw new https.HttpsError("invalid-argument", "Missing couponName");

  const notification = {
    id: generateAppId(),
    type: "new_coupon",
    message: `您已獲得優惠卷：${couponName}！`,
    linkTo: "/coupons",
    timestamp: fieldValue.serverTimestamp(),
    read: false
  };
  await db.collection("users").doc(context.auth.uid)
    .collection("notifications").add(notification);
  return {success: true};
});

// ================================
// 3. 動態牆 Feed & 留言
// ================================
exports.getFeed = functions.https.onCall(async (req) => {
  const {context} = req;
  if (!context.auth)
    throw new https.HttpsError("unauthenticated", "Must be authenticated.");

  const myUid = context.auth.uid;
  const userSnap = await db.collection("users").doc(myUid).get();
  if (!userSnap.exists)
    throw new https.HttpsError("not-found", "User not found");

  const friends = userSnap.data().friends || [];
  const validUids = friends.filter(u => u && u.trim() !== "");
  const feedUids = [myUid, ...validUids].slice(0, 30);
  if (!feedUids.length) return [];

  try {
    const postsSnap = await db.collection("posts")
      .where("authorId", "in", feedUids)
      .orderBy("createdAt", "desc")
      .limit(30).get();

    const feedItems = [];
    postsSnap.forEach(doc => feedItems.push({id: doc.id, ...doc.data()}));
    return feedItems;
  } catch (err) {
    console.error("getFeed failed:", err.message);
    throw new https.HttpsError("internal", "Feed query failed");
  }
});

exports.addCommentToPost = functions.https.onCall(async (req) => {
  const {data, context} = req;
  if (!context.auth)
    throw new https.HttpsError("unauthenticated", "Must be authenticated.");

  const {postId, commentText} = data;
  const commenterUid = context.auth.uid;
  if (!postId || !commentText || !commenterUid)
    throw new https.HttpsError("invalid-argument", "Missing data");

  const userSnap = await db.collection("users").doc(commenterUid).get();
  if (!userSnap.exists)
    throw new https.HttpsError("not-found", "Commenter profile not found");

  const userData = userSnap.data();
  const newComment = {
    authorId: commenterUid,
    authorDisplayName: userData.displayName,
    authorAvatarUrl: userData.avatarUrl,
    text: commentText,
    timestamp: fieldValue.serverTimestamp()
  };

  await db.collection("posts").doc(postId)
    .collection("comments").add(newComment);
  return {success: true, comment: newComment};
});

exports.sendCommentNotification = onDocumentCreated(
  "posts/{postId}/comments/{commentId}", async (event) => {
    const {data: snapshot, params} = event;
    if (!snapshot) return null;

    const commentData = snapshot.data();
    const postId = params.postId;
    const commenterId = commentData.authorId;

    const postDoc = await db.collection("posts").doc(postId).get();
    if (!postDoc.exists) return null;

    const postAuthorId = postDoc.data().authorId;
    if (postAuthorId === commenterId) return null;

    const commenterName = commentData.authorDisplayName || "有人";
    const notification = {
      id: generateAppId(),
      type: "new_comment",
      message: `${commenterName} 在您的貼文上留言。`,
      from: commenterName,
      fromUid: commenterId,
      linkTo: `/post/${postId}`,
      timestamp: fieldValue.serverTimestamp(),
      read: false
    };
    try {
      await db.collection("users").doc(postAuthorId)
        .collection("notifications").add(notification);
    } catch (err) {
      console.error(`Failed comment notification to ${postAuthorId}`, err);
    }
    return null;
});

// ================================
// 4. 使用者位置更新
// ================================
exports.updateUserLocation = functions.https.onCall(async (req) => {
  const {data, context} = req;
  if (!context.auth)
    throw new https.HttpsError("unauthenticated", "Must be authenticated.");

  const {latlng} = data;
  if (!latlng || typeof latlng.lat !== "number" || typeof latlng.lng !== "number")
    throw new https.HttpsError("invalid-argument", "Invalid latlng");

  await db.collection("users").doc(context.auth.uid).update({
    latlng,
    updatedAt: fieldValue.serverTimestamp()
  });
  return {success: true};
});

// ================================
// 5. 聊天通知
// ================================
exports.sendChatNotification = onDocumentCreated(
  "chats/{chatId}/messages/{messageId}", async (event) => {
    const {data: snapshot, params} = event;
    if (!snapshot) return null;

    const messageData = snapshot.data();
    const chatId = params.chatId;
    const senderId = messageData.senderId;
    if (!messageData || !chatId || !senderId) return null;

    const chatDoc = await db.collection("chats").doc(chatId).get();
    if (!chatDoc.exists) return null;

    const participants = chatDoc.data().participants || [];
    const recipientId = participants.find(uid => uid !== senderId);
    if (!recipientId) return null;

    const senderSnap = await db.collection("users").doc(senderId).get();
    const senderName = senderSnap.exists ? senderSnap.data().displayName : "有人";

    const notification = {
      id: generateAppId(),
      type: "chat_message",
      message: `${senderName} 傳送了一則新訊息給您。`,
      from: senderName,
      fromUid: senderId,
      linkTo: `/chat/${chatId}`,
      timestamp: fieldValue.serverTimestamp(),
      read: false
    };
    try {
      await db.collection("users").doc(recipientId)
        .collection("notifications").add(notification);
    } catch (err) {
      console.error(`Failed chat notification to ${recipientId}`, err);
    }
    return null;
});
